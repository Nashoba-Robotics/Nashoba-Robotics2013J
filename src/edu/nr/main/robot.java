// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package edu.nr.main;
import edu.nr.main.commands.AutonomousCommand;
import edu.nr.main.subsystems.ArticulatingArm;
import edu.nr.main.subsystems.Compressor;
import edu.nr.main.subsystems.Track;
import edu.nr.main.subsystems.Shooter;
import edu.nr.main.subsystems.Tipping;
import edu.nr.main.subsystems.FixedArm;
import edu.nr.main.subsystems.Drive;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
/**
 * The VM is configured to automatically run this class, and to call the
 functions corresponding to each mode, as described in the Iterativerobot
 documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class robot extends IterativeRobot 
{
    private int dashboardCounter = 0;
    Command autonomousCommand;
    public static oi oi;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static Drive drive;
    public static Shooter shooter;
    public static Track track;
    public static Tipping tipping;
    public static Compressor compressor;
    public static ArticulatingArm articulatingArm;
    public static FixedArm fixedArm;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    public void robotInit() 
    {
	robot_map.init();
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        drive = new Drive();
        shooter = new Shooter();
        track = new Track();
        tipping = new Tipping();
        compressor = new Compressor();
        articulatingArm = new ArticulatingArm();
        fixedArm = new FixedArm();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // This MUST be here. If the oi creates Commands (which it very likely
        // will), constructing it during the construction of CommandBase (from
        // which commands extend), subsystems are not guaranteed to be
        // yet. Thus, their requires() statements may grab null pointers. Bad
        // news. Don't move it.
        oi = new oi();
	
        // instantiate the command used for the autonomous period
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        autonomousCommand = new AutonomousCommand();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
    }
    public void autonomousInit() 
    {
        // schedule the autonomous command (example)
        if (autonomousCommand != null) autonomousCommand.start();
    }
    /**
     * This function is called periodically during autonomous
     */
    public void autonomousPeriodic() 
    {
        Scheduler.getInstance().run();
    }
    public void teleopInit() 
    {
        
	// This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to 
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null) autonomousCommand.cancel();
    }
    /**
     * This function is called periodically during operator control
     */
    public void teleopPeriodic() 
    {
        dashboardCounter++;
	double timesPerSecond = 5.0;

	timesPerSecond = SmartDashboard.getNumber("SD Times Per Second");

	if(timesPerSecond < 0)
	{
		timesPerSecond = 1;
	}
	int updateRate = (int)((50/timesPerSecond) + 0.5);
	if((dashboardCounter % updateRate) == 0)
	{
		//High Pressure Limit Sensor
		SmartDashboard.putBoolean("Pressure Limit Sensor", robot_map.compressorLimiter.get());
		
		SmartDashboard.putNumber("Gyro Sensor", robot.drive.getGyroAngle());
		SmartDashboard.putNumber("Track Analog Force 1", robot_map.trackForce1.getVoltage());
		SmartDashboard.putNumber("Track Analog Force 2", robot_map.trackForce2.getVoltage());
		
		//Subsystems
		SmartDashboard.putData(robot.drive);
		SmartDashboard.putData(robot.track);
		SmartDashboard.putData(robot.shooter);
		SmartDashboard.putData(robot.tipping);
		SmartDashboard.putData(robot.articulatingArm);
		SmartDashboard.putData(robot.compressor);
	}
        Scheduler.getInstance().run();
    }
    /**
     * This function called periodically during test mode
     */
    public void testPeriodic() 
    {
        
    }
}