// robotBuilder Version: 0.0.2
//
// This file was generated by robotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from robotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package edu.nr.main;
import edu.nr.main.commands.auton;
import edu.nr.main.subsystems.artic;
import edu.nr.main.subsystems.cmprs;
import edu.nr.main.subsystems.trck;
import edu.nr.main.subsystems.sht;
import edu.nr.main.subsystems.tip;
import edu.nr.main.subsystems.fixed;
import edu.nr.main.subsystems.drv;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.can.CANTimeoutException;
import java.lang.Math;
/**
 * The VM is configured to automatically run this class, and to call the
 functions corresponding to each mode, as described in the IterativeRobot
 documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class robot extends IterativeRobot 
{
    private int dashboardCounter = 0;
    Command autonomousCommand;
    public static oi oi;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static drv drive;
    public static sht shooter;
    public static trck track;
    public static tip tipping;
    public static cmprs compressor;
    public static artic articulatingArm;
    public static fixed fixedArm;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    /**
     * 
     */
    public void pid_loop_vals_find() {
        double fl_enc = 0, rl_enc = 0, fr_enc = 0, rr_enc = 0;
        double last_fl_enc = 0, last_rl_enc = 0, last_fr_enc = 0, last_rr_enc = 0;
        double tmp_fl_enc = 0, tmp_rl_enc = 0, tmp_fr_enc = 0, tmp_rr_enc = 0;
        double init_fl_enc = 0, init_rl_enc = 0, init_fr_enc = 0, init_rr_enc = 0;
        double dfl_enc = 0, drl_enc = 0, dfr_enc = 0, drr_enc = 0;
        double dy_rot = 0, dx_rot = 0, dtheta_rot = 0;
        double y = 0, x = 0, theta = 0;
        double dy = 0, dx = 0, dtheta = 0;
        final double t_to_i = 6*Math.PI;
        final double lr = 37.0/2.0;
        
        try {
            fl_enc = robot_map.frontLeftJag.getPosition();
            rl_enc = robot_map.rearLeftJag.getPosition();
            fr_enc = robot_map.frontRightJag.getPosition();
            rr_enc = robot_map.rearRightJag.getPosition();
        }
        catch (CANTimeoutException e) {
            System.err.println("Exception caught: " + e.getMessage());
        }
        
        dfr_enc = (fr_enc - last_fr_enc) * t_to_i;
        drr_enc = (rr_enc - last_rr_enc) * t_to_i;
        dfl_enc = (fl_enc - last_fl_enc) * t_to_i;
        drl_enc = (rl_enc - last_fl_enc) * t_to_i;
        
        last_fr_enc = fr_enc;
        last_rr_enc = rr_enc;
        last_fl_enc = fl_enc;
        last_rl_enc = rl_enc;
        
        dy_rot = (dfr_enc + drr_enc + dfl_enc + drl_enc) / 4.0;
        dx_rot = (dfr_enc + drr_enc - dfl_enc + drl_enc) / 4.0;
        dtheta_rot = (dfr_enc - drr_enc - dfl_enc + drl_enc) / 4.0;
        
        dx = dx_rot * Math.cos(-theta) - dy_rot * Math.sin(-theta);
        dy = dx_rot * Math.sin(-theta) + dy_rot * Math.sin(-theta);
        dtheta = dtheta_rot;
        
        x += dx;
        y += dy;
        theta += dtheta;
        
        SmartDashboard.putNumber("Theta_PID", theta);
        SmartDashboard.putNumber("X_PID", x);
        SmartDashboard.putNumber("Y_PID", y);
    }
    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    public void robotInit() 
    {
	robot_map.init();
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        drive = new drv();
        shooter = new sht();
        track = new trck();
        tipping = new tip();
        compressor = new cmprs();
        articulatingArm = new artic();
        fixedArm = new fixed();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // This MUST be here. If the oi creates Commands (which it very likely
        // will), constructing it during the construction of CommandBase (from
        // which commands extend), subsystems are not guaranteed to be
        // yet. Thus, their requires() statements may grab null pointers. Bad
        // news. Don't move it.
        oi = new oi();
	
        // instantiate the command used for the autonomous period
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        autonomousCommand = new auton();
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
    }
    public void autonomousInit() 
    {
        // schedule the autonomous command (example)
        if (autonomousCommand != null) autonomousCommand.start();
    }
    /**
     * This function is called periodically during autonomous
     */
    public void autonomousPeriodic() 
    {
        Scheduler.getInstance().run();
    }
    public void teleopInit() 
    {
        
	// This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to 
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null) autonomousCommand.cancel();
    }
    /**
     * This function is called periodically during operator control
     */
    public void teleopPeriodic() 
    {
        dashboardCounter++;
	double timesPerSecond = 5.0;

	timesPerSecond = SmartDashboard.getNumber("SD Times Per Second");

	if(timesPerSecond < 0)
	{
		timesPerSecond = 1;
	}
	int updateRate = (int)((50/timesPerSecond) + 0.5);
	if((dashboardCounter % updateRate) == 0)
	{
            //High Pressure Limit Sensor
            SmartDashboard.putBoolean("Pressure Limit Sensor", robot_map.compressorLimiter.get());

            SmartDashboard.putNumber("Gyro Sensor", robot.drive.getGyroAngle());
            SmartDashboard.putNumber("Track Analog Force 1", robot_map.trackForce1.getVoltage());
            SmartDashboard.putNumber("Track Analog Force 2", robot_map.trackForce2.getVoltage());

            //Subsystems
            SmartDashboard.putData(robot.drive);
            SmartDashboard.putData(robot.track);
            SmartDashboard.putData(robot.shooter);
            SmartDashboard.putData(robot.tipping);
            SmartDashboard.putData(robot.articulatingArm);
            SmartDashboard.putData(robot.compressor);
            pid_loop_vals_find();
	}
        Scheduler.getInstance().run();
    }
    /**
     * This function called periodically during test mode
     */
    public void testPeriodic() 
    {
        
    }
}