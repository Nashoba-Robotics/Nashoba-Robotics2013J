// robotBuilder Version: 0.0.2
//
// This file was generated by robotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from robotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package edu.nr.main;
import edu.nr.main.commands.Autonomous;
import edu.nr.main.subsystems.ArticulatedArm;
import edu.nr.main.subsystems.Compressor;
import edu.nr.main.subsystems.Track;
import edu.nr.main.subsystems.Shooter;
import edu.nr.main.subsystems.Tipper;
import edu.nr.main.subsystems.FixedArm;
import edu.nr.main.subsystems.Drivetrain;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.can.CANTimeoutException;
import java.lang.Math;
/**
 * The VM is configured to automatically run this class, and to call the
 functions corresponding to each mode, as described in the IterativeRobot
 documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class RobotMain extends IterativeRobot {
    private int dashboardCounter = 0;
    Command autonomousCommand;
    public static OperatorInput oi;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static Drivetrain drive;
    public static Shooter shooter;
    public static Track track;
    public static Tipper tipping;
    public static Compressor compressor;
    public static ArticulatedArm articulatingArm;
    public static FixedArm fixedArm;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    /**
     * 
     */
    public void pid_loop_vals_find() {
        double fl_enc = 0, rl_enc = 0, fr_enc = 0, rr_enc = 0;
        double last_fl_enc = 0, last_rl_enc = 0, last_fr_enc = 0, last_rr_enc = 0;
        double tmp_fl_enc = 0, tmp_rl_enc = 0, tmp_fr_enc = 0, tmp_rr_enc = 0;
        double init_fl_enc = 0, init_rl_enc = 0, init_fr_enc = 0, init_rr_enc = 0;
        double dfl_enc = 0, drl_enc = 0, dfr_enc = 0, drr_enc = 0;
        double dy_rot = 0, dx_rot = 0, dtheta_rot = 0;
        double y = 0, x = 0, theta = 0;
        double dy = 0, dx = 0, dtheta = 0;
        final double t_to_i = 6*Math.PI;
        final double lr = 37.0/2.0;
        
        try {
            fl_enc = RobotMap.frontLeftJag.getPosition();
            rl_enc = RobotMap.rearLeftJag.getPosition();
            fr_enc = RobotMap.frontRightJag.getPosition();
            rr_enc = RobotMap.rearRightJag.getPosition();
        }
        catch (CANTimeoutException e) {
            System.err.println("Exception caught: " + e.getMessage());
        }
        
        dfr_enc = (fr_enc - last_fr_enc) * t_to_i;
        drr_enc = (rr_enc - last_rr_enc) * t_to_i;
        dfl_enc = (fl_enc - last_fl_enc) * t_to_i;
        drl_enc = (rl_enc - last_fl_enc) * t_to_i;
        
        last_fr_enc = fr_enc;
        last_rr_enc = rr_enc;
        last_fl_enc = fl_enc;
        last_rl_enc = rl_enc;
        
        dy_rot = (dfr_enc + drr_enc + dfl_enc + drl_enc) / 4.0;
        dx_rot = (dfr_enc + drr_enc - dfl_enc + drl_enc) / 4.0;
        dtheta_rot = (dfr_enc - drr_enc - dfl_enc + drl_enc) / 4.0;
        
        dx = dx_rot * Math.cos(-theta) - dy_rot * Math.sin(-theta);
        dy = dx_rot * Math.sin(-theta) + dy_rot * Math.sin(-theta);
        dtheta = dtheta_rot;
        
        x += dx;
        y += dy;
        theta += dtheta;
        
        SmartDashboard.putNumber("Theta_PID", theta);
        SmartDashboard.putNumber("X_PID", x);
        SmartDashboard.putNumber("Y_PID", y);
    }
    /**
     * This function is run when the RobotMain is first started up and should be
 used for any initialization code.
     */
    public void robotInit() 
    {
	RobotMap.init();
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        drive = new Drivetrain();
        shooter = new Shooter();
        track = new Track();
        tipping = new Tipper();
        compressor = new Compressor();
        articulatingArm = new ArticulatedArm();
        fixedArm = new FixedArm();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // This MUST be here. If the OperatorInput creates Commands (which it very likely
        // will), constructing it during the construction of CommandBase (from
        // which commands extend), subsystems are not guaranteed to be
        // yet. Thus, their requires() statements may grab null pointers. Bad
        // news. Don't move it.
        oi = new OperatorInput();
	
        // instantiate the command used for the autonomous period
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        autonomousCommand = new Autonomous();
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
    }
    public void autonomousInit() 
    {
        // schedule the autonomous command (example)
        if (autonomousCommand != null) autonomousCommand.start();
    }
    /**
     * This function is called periodically during Autonomousomous
     */
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
    }
    
    public void teleopInit() {
        
	// This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to 
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null) autonomousCommand.cancel();
    }
    /**
     * This function is called periodically during operator control
     */
    public void teleopPeriodic() {
        dashboardCounter++;
	double timesPerSecond = 5.0;

	timesPerSecond = SmartDashboard.getNumber("SD Update Frequency");

	if(timesPerSecond < 0)
	{
		timesPerSecond = 1;
	}
	int updateRate = (int)((50/timesPerSecond) + 0.5);
	if((dashboardCounter % updateRate) == 0)
	{
            //High Pressure Limit Sensor
            SmartDashboard.putBoolean("Pressure Limit Sensor", RobotMap.compressorLimiter.get());

            SmartDashboard.putNumber("Gyro Sensor", RobotMain.drive.getGyroAngle());
            SmartDashboard.putNumber("Track Analog Force 1", RobotMap.trackForce1.getVoltage());
            SmartDashboard.putNumber("Track Analog Force 2", RobotMap.trackForce2.getVoltage());

            //Subsystems
            SmartDashboard.putData(RobotMain.drive);
            SmartDashboard.putData(RobotMain.track);
            SmartDashboard.putData(RobotMain.shooter);
            SmartDashboard.putData(RobotMain.tipping);
            SmartDashboard.putData(RobotMain.articulatingArm);
            SmartDashboard.putData(RobotMain.compressor);
	}
        Scheduler.getInstance().run();
        pid_loop_vals_find();
    }
}